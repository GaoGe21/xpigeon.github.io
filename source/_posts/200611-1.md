---
title: study / React Hook篇
date: 2020-06-11 23:47:12
tags: study
---


> 最近打算使用**React Hook** +**TypeScript**打造一个前端的组件库，所以在此之前先对React Hook进行了相关总结，方便复习和巩固，后续也会更新TS篇。

---

React 在16.8中推出了Hook的概念，开始使用**function**组件来替代**class**组件。

hook是一个特殊的函数，它提供了相关的钩子函数，用来钩入react的特性。


Hook实质上解决了以下问题：

- 1.组件很难复用状态逻辑

- 2.复杂组件难以理解，尤其是生命周期里，会包含不相关的逻辑

- 3.高阶组件不能修改函数组件内部的状态，只能在外部修改后，通过props传入


---

以下介绍hook中提供的一系列钩子函数，用来帮助函数组件实现管理内部的state。

- [x]  **1.useState**

useState函数接受一个参数，作为当前state的默认值。它的返回值为当前 state 以及更新 state 的函数（理解为class中定义的一个state和更新这个state时调用的setState），state可以是任何简单类型，也可以是复杂类型对象。


首先创建class组件实现以下功能：在button组件上显示点赞次数，且每点击一次都会执行+1：

```
class LikeButton extends React.Component {
    constructor(props) {
        super(props);
        this.state = { like: 0 };
    }
    render() {
        return <button onClick={() => this.setState({ like: this.state.like + 1 })}>
            {this.state.like}
        </button>;
    }
}
```
使用函数组件编写如下。直观的区别首先代码量就减少了近一半...

```
// 栗子①
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0);
    return <button onClick={() => setLike(like + 1)}>{like}</button>;
}
```
可以多次调用useState,创建并管理多个state：

```
// 栗子②
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0);
    const [on, setOn] = useState(true);
    return <>
        <button onClick={() => setLike(like + 1)}>{like}</button>
        <button onClick={() => setOn(!on)}> {on ? "ON" : "PFF"} </button>
    </>;
}
```
也可以在一个useState中定义一个对象，来包含多个属性。按个人需求选择任意方式

```
// 栗子③
const LikeButton: React.FC = () => {
    const [obj, setObj] = useState({ like: 0, on: true });
    return <>
        <button onClick={() => setObj({ like: obj.like + 1, on: obj.on })}>
            {obj.like}
        </button>
        <button onClick={() => setObj({ like: obj.like, on: !obj.on })}>
            {obj.on ? "ON" : "PFF"}
        </button>
    </>;
}
```


- [x] **2.useEffect**

官网介绍，这个钩子是用来处理组件副作用的。（类似class组件中生命周期函数）


（1）首先一个无需清除副作用的栗子，例如：网络请求，手动变更DOM，记录日志等；

class组件实现如下，可以看到在两个周期函数中是完全重复的代码，但这是我们的需求，我们需要在组件挂载完成和更新完成后都执行这个操作：
```
componentDidMount() {
    document.title = `You clicked ${this.state.like} times`;
}

componentDidUpdate() {
    document.title = `You clicked ${this.state.like} times`;
}

```
使用useEffect实现如下，这个钩子的第一个参数是一个函数，用来执行相关操作，无论是挂载还是更新，在重新渲染后都会执行useEffect：

```
// 栗子④
const LikeButton: React.FC = () => {
    const [like, setLike] = useState(0);
    const [on, setOn] = useState(true);
    useEffect(() => {
        document.title = `You clicked ${like} times`;
    });
    return <>
        <button onClick={() => setLike(like + 1)}>{like}</button>
        <button onClick={() => setOn(!on)}>{on ? "ON" : "PFF"}</button>
    </>;
}
```

（2）添加监听事件，卸载组件时需要移除监听的栗子：

class组件实现如下，我们需要在挂载阶段添加监听，将要卸载组件时移除：

```
comonentDidMount() {
    document.addEventListener("click", this.updateMouse)
}
comonentWillUnmount() {
    document.removeEventListener("click", this.updateMouse)
}
```
使用useEffect实现如下，只需要在一个useEffect中，第一个参数的函数里执行添加监听，并且return一个函数，这个函数用来执行卸载时的移除：

```
// 栗子⑤
const MouseTracker: React.FC = () => {
    const [positions, setPositions] = useState({ x: 0, y: 0 });
    useEffect(() => {
        const updateMouse = (e: MouseEvent) => {
            setPositions({ x: e.clientX, y: e.clientY })
        }
        document.addEventListener("click", updateMouse);
        return () => {
            document.removeEventListener("click", updateMouse);
        }
    });
    return <p>X: {positions.x},Y: {positions.y}</p>;
}
```
（3）注意：**useEffect会在每次渲染后都执行**！这就会导致，其他state的更新也执行这个与当前state不相关的副作用。

这时useEffect的第二个参数就发挥作用了，它是一个数组，当设置为空数组时，useEffect只会执行一次（可以用来执行数据请求等操作，控制只加载一次）。也可以设置多个值，这样在每个值改变导致重渲染之后都会执行useEffect：

```
// 栗子⑥
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // 仅在 count 更改时更新
```

- [ ] **3.自定义hook**


- [ ] **4.useRef**


- [ ] **5.useContext**
